/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.heapy.argo.client.models

import io.heapy.argo.client.models.Inputs
import io.heapy.argo.client.models.MemoizationStatus
import io.heapy.argo.client.models.NodeFlag
import io.heapy.argo.client.models.NodeSynchronizationStatus
import io.heapy.argo.client.models.Outputs
import io.heapy.argo.client.models.TemplateRef

import kotlinx.serialization.Serializable
import kotlinx.serialization.SerialName
import kotlinx.serialization.Contextual
import kotlin.time.Instant

/**
 * NodeStatus contains status information about an individual node in the workflow
 *
 * @param id ID is a unique identifier of a node within the worklow It is implemented as a hash of the node name, which makes the ID deterministic
 * @param name Name is unique name in the node tree used to generate the node ID
 * @param type Type indicates type of node
 * @param boundaryID BoundaryID indicates the node ID of the associated template root node in which this node belongs to
 * @param children Children is a list of child node IDs
 * @param daemoned Daemoned tracks whether or not this node was daemoned and need to be terminated
 * @param displayName DisplayName is a human readable representation of the node. Unique within a template boundary
 * @param estimatedDuration EstimatedDuration in seconds.
 * @param finishedAt Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
 * @param hostNodeName HostNodeName name of the Kubernetes node on which the Pod is running, if applicable
 * @param inputs 
 * @param memoizationStatus 
 * @param message A human readable message indicating details about why the node is in this condition.
 * @param nodeFlag 
 * @param outboundNodes OutboundNodes tracks the node IDs which are considered \"outbound\" nodes to a template invocation. For every invocation of a template, there are nodes which we considered as \"outbound\". Essentially, these are last nodes in the execution sequence to run, before the template is considered completed. These nodes are then connected as parents to a following step.  In the case of single pod steps (i.e. container, script, resource templates), this list will be nil since the pod itself is already considered the \"outbound\" node. In the case of DAGs, outbound nodes are the \"target\" tasks (tasks with no children). In the case of steps, outbound nodes are all the containers involved in the last step group. NOTE: since templates are composable, the list of outbound nodes are carried upwards when a DAG/steps template invokes another DAG/steps template. In other words, the outbound nodes of a template, will be a superset of the outbound nodes of its last children.
 * @param outputs 
 * @param phase Phase a simple, high-level summary of where the node is in its lifecycle. Can be used as a state machine. Will be one of these values \"Pending\", \"Running\" before the node is completed, or \"Succeeded\", \"Skipped\", \"Failed\", \"Error\", or \"Omitted\" as a final state.
 * @param podIP PodIP captures the IP of the pod for daemoned steps
 * @param progress Progress to completion
 * @param resourcesDuration ResourcesDuration is indicative, but not accurate, resource duration. This is populated when the nodes completes.
 * @param startedAt Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
 * @param synchronizationStatus 
 * @param taskResultSynced TaskResultSynced is used to determine if the node's output has been received
 * @param templateName TemplateName is the template name which this node corresponds to. Not applicable to virtual nodes (e.g. Retry, StepGroup)
 * @param templateRef 
 * @param templateScope TemplateScope is the template scope in which the template of this node was retrieved.
 */
@Serializable

data class NodeStatus (

    /* ID is a unique identifier of a node within the worklow It is implemented as a hash of the node name, which makes the ID deterministic */
    @SerialName(value = "id")
    val id: kotlin.String,

    /* Name is unique name in the node tree used to generate the node ID */
    @SerialName(value = "name")
    val name: kotlin.String,

    /* Type indicates type of node */
    @SerialName(value = "type")
    val type: kotlin.String,

    /* BoundaryID indicates the node ID of the associated template root node in which this node belongs to */
    @SerialName(value = "boundaryID")
    val boundaryID: kotlin.String? = null,

    /* Children is a list of child node IDs */
    @SerialName(value = "children")
    val children: kotlin.collections.List<kotlin.String>? = null,

    /* Daemoned tracks whether or not this node was daemoned and need to be terminated */
    @SerialName(value = "daemoned")
    val daemoned: kotlin.Boolean? = null,

    /* DisplayName is a human readable representation of the node. Unique within a template boundary */
    @SerialName(value = "displayName")
    val displayName: kotlin.String? = null,

    /* EstimatedDuration in seconds. */
    @SerialName(value = "estimatedDuration")
    val estimatedDuration: kotlin.Int? = null,

    /* Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
    @Contextual @SerialName(value = "finishedAt")
    val finishedAt: Instant? = null,

    /* HostNodeName name of the Kubernetes node on which the Pod is running, if applicable */
    @SerialName(value = "hostNodeName")
    val hostNodeName: kotlin.String? = null,

    @SerialName(value = "inputs")
    val inputs: Inputs? = null,

    @SerialName(value = "memoizationStatus")
    val memoizationStatus: MemoizationStatus? = null,

    /* A human readable message indicating details about why the node is in this condition. */
    @SerialName(value = "message")
    val message: kotlin.String? = null,

    @SerialName(value = "nodeFlag")
    val nodeFlag: NodeFlag? = null,

    /* OutboundNodes tracks the node IDs which are considered \"outbound\" nodes to a template invocation. For every invocation of a template, there are nodes which we considered as \"outbound\". Essentially, these are last nodes in the execution sequence to run, before the template is considered completed. These nodes are then connected as parents to a following step.  In the case of single pod steps (i.e. container, script, resource templates), this list will be nil since the pod itself is already considered the \"outbound\" node. In the case of DAGs, outbound nodes are the \"target\" tasks (tasks with no children). In the case of steps, outbound nodes are all the containers involved in the last step group. NOTE: since templates are composable, the list of outbound nodes are carried upwards when a DAG/steps template invokes another DAG/steps template. In other words, the outbound nodes of a template, will be a superset of the outbound nodes of its last children. */
    @SerialName(value = "outboundNodes")
    val outboundNodes: kotlin.collections.List<kotlin.String>? = null,

    @SerialName(value = "outputs")
    val outputs: Outputs? = null,

    /* Phase a simple, high-level summary of where the node is in its lifecycle. Can be used as a state machine. Will be one of these values \"Pending\", \"Running\" before the node is completed, or \"Succeeded\", \"Skipped\", \"Failed\", \"Error\", or \"Omitted\" as a final state. */
    @SerialName(value = "phase")
    val phase: kotlin.String? = null,

    /* PodIP captures the IP of the pod for daemoned steps */
    @SerialName(value = "podIP")
    val podIP: kotlin.String? = null,

    /* Progress to completion */
    @SerialName(value = "progress")
    val progress: kotlin.String? = null,

    /* ResourcesDuration is indicative, but not accurate, resource duration. This is populated when the nodes completes. */
    @SerialName(value = "resourcesDuration")
    val resourcesDuration: kotlin.collections.Map<kotlin.String, kotlin.Long>? = null,

    /* Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers. */
    @Contextual @SerialName(value = "startedAt")
    val startedAt: Instant? = null,

    @SerialName(value = "synchronizationStatus")
    val synchronizationStatus: NodeSynchronizationStatus? = null,

    /* TaskResultSynced is used to determine if the node's output has been received */
    @SerialName(value = "taskResultSynced")
    val taskResultSynced: kotlin.Boolean? = null,

    /* TemplateName is the template name which this node corresponds to. Not applicable to virtual nodes (e.g. Retry, StepGroup) */
    @SerialName(value = "templateName")
    val templateName: kotlin.String? = null,

    @SerialName(value = "templateRef")
    val templateRef: TemplateRef? = null,

    /* TemplateScope is the template scope in which the template of this node was retrieved. */
    @SerialName(value = "templateScope")
    val templateScope: kotlin.String? = null

) {


}

