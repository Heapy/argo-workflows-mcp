/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.heapy.argo.client.models

import io.heapy.argo.client.models.KubernetesAWSElasticBlockStoreVolumeSource
import io.heapy.argo.client.models.KubernetesAzureDiskVolumeSource
import io.heapy.argo.client.models.KubernetesAzureFileVolumeSource
import io.heapy.argo.client.models.KubernetesCSIVolumeSource
import io.heapy.argo.client.models.KubernetesCephFSVolumeSource
import io.heapy.argo.client.models.KubernetesCinderVolumeSource
import io.heapy.argo.client.models.KubernetesConfigMapVolumeSource
import io.heapy.argo.client.models.KubernetesDownwardAPIVolumeSource
import io.heapy.argo.client.models.KubernetesEmptyDirVolumeSource
import io.heapy.argo.client.models.KubernetesEphemeralVolumeSource
import io.heapy.argo.client.models.KubernetesFCVolumeSource
import io.heapy.argo.client.models.KubernetesFlexVolumeSource
import io.heapy.argo.client.models.KubernetesFlockerVolumeSource
import io.heapy.argo.client.models.KubernetesGCEPersistentDiskVolumeSource
import io.heapy.argo.client.models.KubernetesGitRepoVolumeSource
import io.heapy.argo.client.models.KubernetesGlusterfsVolumeSource
import io.heapy.argo.client.models.KubernetesHostPathVolumeSource
import io.heapy.argo.client.models.KubernetesISCSIVolumeSource
import io.heapy.argo.client.models.KubernetesImageVolumeSource
import io.heapy.argo.client.models.KubernetesNFSVolumeSource
import io.heapy.argo.client.models.KubernetesPersistentVolumeClaimVolumeSource
import io.heapy.argo.client.models.KubernetesPhotonPersistentDiskVolumeSource
import io.heapy.argo.client.models.KubernetesPortworxVolumeSource
import io.heapy.argo.client.models.KubernetesProjectedVolumeSource
import io.heapy.argo.client.models.KubernetesQuobyteVolumeSource
import io.heapy.argo.client.models.KubernetesRBDVolumeSource
import io.heapy.argo.client.models.KubernetesScaleIOVolumeSource
import io.heapy.argo.client.models.KubernetesSecretVolumeSource
import io.heapy.argo.client.models.KubernetesStorageOSVolumeSource
import io.heapy.argo.client.models.KubernetesVsphereVirtualDiskVolumeSource

import kotlinx.serialization.Serializable
import kotlinx.serialization.SerialName
import kotlinx.serialization.Contextual

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @param name name of the volume. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
 * @param awsElasticBlockStore 
 * @param azureDisk 
 * @param azureFile 
 * @param cephfs 
 * @param cinder 
 * @param configMap 
 * @param csi 
 * @param downwardAPI 
 * @param emptyDir 
 * @param ephemeral 
 * @param fc 
 * @param flexVolume 
 * @param flocker 
 * @param gcePersistentDisk 
 * @param gitRepo 
 * @param glusterfs 
 * @param hostPath 
 * @param image 
 * @param iscsi 
 * @param nfs 
 * @param persistentVolumeClaim 
 * @param photonPersistentDisk 
 * @param portworxVolume 
 * @param projected 
 * @param quobyte 
 * @param rbd 
 * @param scaleIO 
 * @param secret 
 * @param storageos 
 * @param vsphereVolume 
 */
@Serializable

data class KubernetesVolume (

    /* name of the volume. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names */
    @SerialName(value = "name")
    val name: kotlin.String,

    @SerialName(value = "awsElasticBlockStore")
    val awsElasticBlockStore: KubernetesAWSElasticBlockStoreVolumeSource? = null,

    @SerialName(value = "azureDisk")
    val azureDisk: KubernetesAzureDiskVolumeSource? = null,

    @SerialName(value = "azureFile")
    val azureFile: KubernetesAzureFileVolumeSource? = null,

    @SerialName(value = "cephfs")
    val cephfs: KubernetesCephFSVolumeSource? = null,

    @SerialName(value = "cinder")
    val cinder: KubernetesCinderVolumeSource? = null,

    @SerialName(value = "configMap")
    val configMap: KubernetesConfigMapVolumeSource? = null,

    @SerialName(value = "csi")
    val csi: KubernetesCSIVolumeSource? = null,

    @SerialName(value = "downwardAPI")
    val downwardAPI: KubernetesDownwardAPIVolumeSource? = null,

    @SerialName(value = "emptyDir")
    val emptyDir: KubernetesEmptyDirVolumeSource? = null,

    @SerialName(value = "ephemeral")
    val ephemeral: KubernetesEphemeralVolumeSource? = null,

    @SerialName(value = "fc")
    val fc: KubernetesFCVolumeSource? = null,

    @SerialName(value = "flexVolume")
    val flexVolume: KubernetesFlexVolumeSource? = null,

    @SerialName(value = "flocker")
    val flocker: KubernetesFlockerVolumeSource? = null,

    @SerialName(value = "gcePersistentDisk")
    val gcePersistentDisk: KubernetesGCEPersistentDiskVolumeSource? = null,

    @SerialName(value = "gitRepo")
    val gitRepo: KubernetesGitRepoVolumeSource? = null,

    @SerialName(value = "glusterfs")
    val glusterfs: KubernetesGlusterfsVolumeSource? = null,

    @SerialName(value = "hostPath")
    val hostPath: KubernetesHostPathVolumeSource? = null,

    @SerialName(value = "image")
    val image: KubernetesImageVolumeSource? = null,

    @SerialName(value = "iscsi")
    val iscsi: KubernetesISCSIVolumeSource? = null,

    @SerialName(value = "nfs")
    val nfs: KubernetesNFSVolumeSource? = null,

    @SerialName(value = "persistentVolumeClaim")
    val persistentVolumeClaim: KubernetesPersistentVolumeClaimVolumeSource? = null,

    @SerialName(value = "photonPersistentDisk")
    val photonPersistentDisk: KubernetesPhotonPersistentDiskVolumeSource? = null,

    @SerialName(value = "portworxVolume")
    val portworxVolume: KubernetesPortworxVolumeSource? = null,

    @SerialName(value = "projected")
    val projected: KubernetesProjectedVolumeSource? = null,

    @SerialName(value = "quobyte")
    val quobyte: KubernetesQuobyteVolumeSource? = null,

    @SerialName(value = "rbd")
    val rbd: KubernetesRBDVolumeSource? = null,

    @SerialName(value = "scaleIO")
    val scaleIO: KubernetesScaleIOVolumeSource? = null,

    @SerialName(value = "secret")
    val secret: KubernetesSecretVolumeSource? = null,

    @SerialName(value = "storageos")
    val storageos: KubernetesStorageOSVolumeSource? = null,

    @SerialName(value = "vsphereVolume")
    val vsphereVolume: KubernetesVsphereVirtualDiskVolumeSource? = null

) {


}

